./ ADD NAME=LPRPRINT
/* ---------------------  rexx procedure  ---------------------- *
 * Name:      LPRPrint                                           *
 *                                                               *
 * Function:  Invoked by the user or via another ISPF dialog     *
 *            to invoke the LPRPRINT ISPF Panel and then use     *
 *            the TCP/IP LPR command to print the specified      *
 *            data set on a TCP/IP connected printer.            *
 *                                                               *
 *            Note that the specified Host must have LPD active  *
 *            to receive the data.                               *
 *                                                               *
 * Syntax:    %lprprint dsname                                   *
 *                                                               *
 *            dsname is optional                                 *
 *                                                               *
 * Author:    Lionel B. Dyck                                     *
 *                                                               *
 * History:                                                      *
 *            02/14/18 - Update to Tutorial panel adding &ZCONT  *
 *                     - recurse into APPL(ISR) if not           *
 *            11/03/17 - Make this a self-contained exec         *
 *                       by imbedding the panels and messages    *
 *            04/30/15 - update to add lprcopy to ispf profile   *
 *                       thx to Peter Giles who found this       *
 *            03/20/97 - save inds in profile                    *
 *            01/10/95 - Remove ack as tcp/ip 3.1 doesn't        *
 *            08/29/94 - update for Postscript option            *
 *            06/23/94 - fix parse for pds dsname                *
 *            01/21/94 - fix for pds input w/member name         *
 *            01/18/94 - add support for member selection if     *
 *                       dsname is pds and no member given       *
 *            01/17/94 - fix for invalid dsn and for messages    *
 *            01/07/94 - add option for additional user specified*
 *                       parameters other than what is directly  *
 *                       supported                               *
 *            01/04/94 - add entry optional parameter of dsn     *
 *                       and support ACK option                  *
 *            01/03/94 - updated to cleanup invocation           *
 *            12/22/93 - creation of application                 *
 *                                                               *
 * ------------------------------------------------------------- */

 arg inds

/* ----------------------------- *
 | Get into ISPF Addressing mode |
 * ----------------------------- */
 Address ISPExec

/* -------------------------------------------------- *
 * Test for our ISPF Applid and if not then:          *
 * - re-invoke ourselves with our APPLID              *
 * - upon return exit                                 *
 * -------------------------------------------------- */
 "Vget (Zapplid)"
 "Control Errors Return"
 if zapplid <> "ISR" then do
     "Select CMD(%"sysvar('sysicmd') inds ") Newappl(ISR)" ,
         "Passlib"
    exit 0
    end

/* --------------------------------------------- *
 | Dynamically load the ISPF Panels and Messages |
 * --------------------------------------------- */
 load_info = loadispf()

/* ------------------------------------- *
 | Display the LPRPRINT Panel until Exit |
 * ------------------------------------- */
 do forever
/* ---------------------------------- *
 | Get the variables from the profile |
 * ---------------------------------- */
   "VGET (lprdest lprhost lprbin lprcc lprntfy lprlcnt lprhead ",
         "lprcopy lprburst lprntfy lprps lpruopt lprpinds) Profile"
    if length(inds) > 0 then lprpinds = inds
    "Display Panel(LPRPRINT)"
    if rc > 3 then call do_exit
/* --------------------------------- *
 | Svae the variables in the profile |
 * --------------------------------- */
   "VPUT (lprdest lprhost lprbin lprcc lprntfy lprlcnt lprhead ",
         "lprcopy lprburst lprntfy lprps lpruopt lprpinds) Profile"

/* ------------------------------- *
 | Validate the input dataset name |
 * ------------------------------- */
 if sysdsn(lprpinds) <> "OK" then do
    lprsmsg = "Error"
    lprlmsg = "Specified data set does not exist:" lprpinds
    "Vput (lprsmsg lprlmsg)"
    "SETMSG MSG(LPR002)"
    end
 else do
     /* ------------------------------------ *
      | DSN Valid - now setup for Processing |
      * ------------------------------------ */
      parse value "" with binary cc mail line_count header burst,
                     copies postscr
      if lprbin   = "Yes" then binary = "Binary"
      if lprcc    = "Yes" then cc     = "CC"
                          else cc     = "NOCC"
      if lprntfy  = "Yes" then mail   = "Mail"
      if lprhead  = "No"  then header = "NoHeader"
      if lprburst = "No"  then burst  = "NoBurst"
      if lprcopy  > 1     then copies = "Copies" lprcopy
      if lprlcnt  > 0     then line_count = "Linecount" lprlcnt
      if lprps    = "Portrait"  then postscr = "Postscript"
      if lprps    = "Landscape" then postscr = "Landscape"

      x = listdsi(lprpinds)
      if pos("(",lprpinds) > 0 then sysdsorg = "PS"
      Select
        When sysdsorg = "PS" | pos("(",lprpinds) > 1
             then call do_lpr lprpinds
        When sysdsorg = "PO"
             then call do_pds
        Otherwise nop;
      end
      end
 end

/* --------------------------------------------- *
 | If a PDS and no Member then prompt for Member |
 * --------------------------------------------- */
 do_pds:
    "Lminit Dataid(dataid) Dataset("lprpinds") Enq(Shrw)"
    "Lmopen Dataid("dataid") Option(Input)"
    "Lmmdisp Dataid("dataid") Option(Display)",
      "Commands(Any) Panel(LPRPM)"
      do while rc == 0
         Call process_selection
        "Lmmdisp Dataid("dataid") Option(Get)"
         if rc == 8
            then "Lmmdisp Dataid("dataid") Option(Display)",
                 "Commands(Any) Panel(LPRPM)"
      end
      "Lmmdisp Dataid("dataid") Option(Free)"
      "Lmclose Dataid("dataid")"
      "Lmfree  Dataid("dataid")"
    return

 process_selection:
    if left(lprpinds,1) = "'"
       then parse value lprpinds with "'" w_dsn "'"
       else w_dsn = sysvar("syspref")"."lprpinds
    zlmember = strip(zlmember)
    Select
    When zllcmd = "/" | zllcmd = "S"
    Then do
      "Lmmdisp Dataid("dataid") Option(Put) Member("zlmember")",
          "Zludata(printed)"
      call do_lpr "'"w_dsn"("zlmember")'"
      end
    When zllcmd = "B"
    Then "Browse Dataid("dataid") Member("zlmember")"
    Otherwise nop;
    End
    return

/* ------------------------------------------------- *
 | Execute the LPR command to do the actual printing |
 * ------------------------------------------------- */
 do_lpr:
    arg dsn
   cmd = "LPR" dsn "(Printer" lprdest "Host" lprhost "Type",
         binary cc mail line_count header burst copies ,
         postscr lpruopt
   Address TSO  cmd
   if sysdsorg <> "PS" then return
   lprsmsg = ""
   lprlmsg = lprpinds "printed to" lprdest "at" lprhost
  "Vput (lprsmsg lprlmsg)"
  "SETMSG MSG(LPR002)"
   return

/* ------------ *
 | Exit routine |
 * ------------ */
 Do_Exit:
    Address ISPEXEC
    do until length(load_info) = 0
       parse value load_info with dd libd load_info
       "libdef" libd
       address tso "free f("dd")"
       end
    exit

/* --------------------  rexx procedure  -------------------- *
 * Name:      LoadISPF                                        *
 *                                                            *
 * Function:  Load ISPF elements that are inline in the       *
 *            REXX source code.                               *
 *                                                            *
 * Syntax:    rc = loadispf()                                 *
 *                                                            *
 *            The inline ISPF resources are limited to        *
 *            ISPF Messages, Panels, and Skeletons,           *
 *                 CLISTs and EXECs are also supported.       *
 *                                                            *
 *            The inline resources must start in column 1     *
 *            and use the following syntax:                   *
 *                                                            *
 *            >START    used to indicate the start of the     *
 *                      inline data                           *
 *                                                            *
 *            >END    - used to indicate the end of the       *
 *                      inline data                           *
 *                                                            *
 *            Each resource begins with a type record:        *
 *            >type name                                      *
 *               where type is CLIST, EXEC, MSG, PANEL, SKEL  *
 *                     name is the name of the element        *
 *                                                            *
 * Sample usage:                                              *
 *          -* rexx *-                                        *
 *          load_info = loadispf()                            *
 *          ... magic code happens here (your code) ...       *
 *          Address ISPEXEC                                   *
 *          do until length(load_info) = 0                    *
 *             parse value load_info with dd libd load_info   *
 *             if left(libd,6) = "ALTLIB" then do             *
 *                if libd = "ALTLIBC" then lib = "CLIST"      *
 *                                    else lib = "EXEC"       *
 *                Address TSO,                                *
 *                  "Altlib Deact Application("lib")"         *
 *                end                                         *
 *             else "libdef" libd                             *
 *             address tso "free f("dd")"                     *
 *             end                                            *
 *          exit                                              *
 *          >Start inline elements                            *
 *          >Panel panel1                                     *
 *          ...                                               *
 *          >Msg msg1                                         *
 *          ...                                               *
 *          >End of inline elements                           *
 *                                                            *
 * Returns:   the list of ddnames allocated for use along     *
 *            with the libdef's performed or altlib           *
 *                                                            *
 *            format is ddname libdef ddname libdef ...       *
 *                   libdef may be altlibc or altlibe         *
 *                   for altlib clist or altlib exec          *
 *                                                            *
 * Notes:     Entire routine must be included with REXX       *
 *            exec - inline with the code.                    *
 *                                                            *
 * Comments:  The entire rexx program is processed from the   *
 *            last record to the first to find the >START     *
 *            record at which point all records from that     *
 *            point on are processed until the >END           *
 *            statement or the end of the program is found.   *
 *                                                            *
 *            It is *strongly* suggested that the inline      *
 *            elements be at the very end of your code so     *
 *            that the search for them is faster.             *
 *                                                            *
 *            Inline ISPTLIB or ISPLLIB were not supported    *
 *            because the values for these would have to be   *
 *            in hex.                                         *
 *                                                            *
 * Author:    Lionel B. Dyck                                  *
 *                                                            *
 * History:                                                   *
 *            08/29/17 - Fixup static values that were vars   *
 *            05/31/17 - Change default directory count       *
 *            12/09/16 - update for add_it routine            *
 *            05/10/16 - correction for clist and exec        *
 *            04/19/16 - bug correction                       *
 *            06/04/04 - Enhancements for speed               *
 *            08/05/02 - Creation                             *
 *                                                            *
 * ---------------------------------------------------------- *
 * Disclaimer: There is no warranty, either explicit or       *
 * implied with this code. Use it at your own risk as there   *
 * is no recourse from either the author or his employeer.    *
 * ---------------------------------------------------------- */
 LoadISPF: Procedure

 parse value "" with null kmsg kpanel kskel first returns ,
                     kclist kexec
/* ------------------------------------------------------- *
 * Find the InLine ISPF Elements and load them into a stem *
 * variable.                                               *
 *                                                         *
 * Elements keyword syntax:                                *
 * >START - start of inline data                           *
 * >CLIST name                                             *
 * >EXEC name                                              *
 * >MSG name                                               *
 * >PANEL name                                             *
 * >SKEL name                                              *
 * >END   - end of all inline data (optional if last)      *
 * ------------------------------------------------------- */
 last_line = sourceline()
 do i = last_line to 1 by -1
    line = sourceline(i)
    if translate(left(line,6)) = ">START " then leave
    end
 rec = 0
/* --------------------------------------------------- *
 * Flag types of ISPF resources by testing each record *
 * then add each record to the data. stem variable.    *
 * --------------------------------------------------- */
 do j = i+1 to last_line
    line = sourceline(j)
    if translate(left(line,5)) = ">END "   then leave
    if translate(left(line,7)) = ">CLIST " then kclist = 1
    if translate(left(line,6)) = ">EXEC "  then kexec  = 1
    if translate(left(line,5)) = ">MSG "   then kmsg   = 1
    if translate(left(line,7)) = ">PANEL " then kpanel = 1
    if translate(left(line,6)) = ">SKEL "  then kskel  = 1
    rec  = rec + 1
    data.rec = line
    end

/* ----------------------------------------------------- *
 * Now create the Library and Load the Member(s)         *
 * ----------------------------------------------------- */
 Address ISPExec
/* ----------------------------- *
 * Assign dynamic random ddnames *
 * ----------------------------- */
 clistdd = "lc"random(999)
 execdd  = "le"random(999)
 msgdd   = "lm"random(999)
 paneldd = "lp"random(999)
 skeldd  = "ls"random(999)

/* ---------------------------------------- *
 *  LmInit and LmOpen each resource library *
 * ---------------------------------------- */
 if kclist <> null then do
    call alloc_dd clistdd
    "Lminit dataid(clist) ddname("clistdd")"
    "LmOpen dataid("clist") Option(Output)"
    returns = strip(returns clistdd 'ALTLIBC')
    end
 if kexec <> null then do
    call alloc_dd execdd
    "Lminit dataid(exec) ddname("execdd")"
    "LmOpen dataid("exec") Option(Output)"
    returns = strip(returns execdd 'ALTLIBE')
    end
 if kmsg <> null then do
    call alloc_dd msgdd
    "Lminit dataid(msg) ddname("msgdd")"
    "LmOpen dataid("msg") Option(Output)"
    returns = strip(returns msgdd 'ISPMLIB')
    end
 if kpanel <> null then do
    call alloc_dd paneldd
    "Lminit dataid(panel) ddname("paneldd")"
    "LmOpen dataid("panel") Option(Output)"
    returns = strip(returns paneldd 'ISPPLIB')
    end
 if kskel <> null then do
    call alloc_dd skeldd
    "Lminit dataid(skel) ddname("skeldd")"
    "LmOpen dataid("skel") Option(Output)"
    returns = strip(returns skeldd 'ISPSLIB')
    end

/* ----------------------------------------------- *
 * Process all records in the data. stem variable. *
 * ----------------------------------------------- */
 do i = 1 to rec
    record = data.i
    recordu = translate(record)
    if left(recordu,5) = ">END " then leave
    if left(recordu,7) = ">CLIST " then do
       if first = 1 then call add_it
       type = "Clist"
       first = 1
       parse value record with x name
       iterate
       end
    if left(recordu,6) = ">EXEC " then do
       if first = 1 then call add_it
       type = "Exec"
       first = 1
       parse value record with x name
       iterate
       end
    if left(recordu,5) = ">MSG " then do
       if first = 1 then call add_it
       type = "Msg"
       first = 1
       parse value record with x name
       iterate
       end
    if left(recordu,7) = ">PANEL " then do
       if first = 1 then call add_it
       type = "Panel"
       first = 1
       parse value record with x name
       iterate
       end
    if left(recordu,6) = ">SKEL " then do
       if first = 1 then call add_it
       type = "Skel"
       first = 1
       parse value record with x name
       iterate
       end
   /* --------------------------------------------*
    * Put the record into the appropriate library *
    * based on the record type.                   *
    * ------------------------------------------- */
    Select
      When type = "Clist" then
           "LmPut dataid("clist") MODE(INVAR)" ,
                 "DataLoc(record) DataLen(255)"
      When type = "Exec" then
           "LmPut dataid("exec") MODE(INVAR)" ,
                 "DataLoc(record) DataLen(255)"
      When type = "Msg" then
           "LmPut dataid("msg") MODE(INVAR)" ,
                 "DataLoc(record) DataLen(80)"
      When type = "Panel" then
           "LmPut dataid("panel") MODE(INVAR)" ,
                 "DataLoc(record) DataLen(80)"
      When type = "Skel" then
           "LmPut dataid("skel") MODE(INVAR)" ,
                 "DataLoc(record) DataLen(80)"
      Otherwise nop
      end
    end
 if type <> null then call add_it
/* ---------------------------------------------------- *
 * Processing completed - now lmfree the allocation and *
 * Libdef the library.                                  *
 * ---------------------------------------------------- */
 if kclist <> null then do
    Address TSO,
    "Altlib Act Application(Clist) File("clistdd")"
    "LmFree dataid("clist")"
    end
 if kexec <> null then do
    Address TSO,
    "Altlib Act Application(Exec) File("execdd")"
    "LmFree dataid("exec")"
    end
 if kmsg <> null then do
    "LmFree dataid("msg")"
    "Libdef ISPMlib Library ID("msgdd") Stack"
    end
 if kpanel <> null then do
    "Libdef ISPPlib Library ID("paneldd") Stack"
    "LmFree dataid("panel")"
    end
 if kskel <> null then do
    "Libdef ISPSlib Library ID("skeldd") Stack"
    "LmFree dataid("skel")"
    end
 return returns

/* --------------------------- *
 * Add the Member using LmmAdd *
 * based upon type of resource *
 * --------------------------- */
 Add_It:
 Select
    When type = "Clist" then
         "LmmAdd dataid("clist") Member("name")"
    When type = "Exec" then
         "LmmAdd dataid("exec") Member("name")"
    When type = "Msg" then
         "LmmAdd dataid("msg") Member("name")"
    When type = "Panel" then
         "LmmAdd dataid("panel") Member("name")"
    When type = "Skel" then
         "LmmAdd dataid("skel") Member("name")"
    Otherwise nop
    end
 type = null
 return

/* ------------------------------ *
 * ALlocate the temp ispf library *
 * ------------------------------ */
 Alloc_DD:
 arg dd
 Address TSO
 if pos(left(dd,2),"lc le") > 0 then
 "Alloc f("dd") unit(sysda) spa(5,5) dir(5)",
    "recfm(v b) lrecl(255) blksize(32760)"
 else
 "Alloc f("dd") unit(sysda) spa(5,5) dir(5)",
    "recfm(f b) lrecl(80) blksize(23440)"
 return
/*
>START
>PANEL LPRPH0
)Attr Default(@+_)
/* _ type( input) intens(high) caps(on ) just(left )               */
   ! type(text) intens(high) caps(off) just(asis ) color(white)
      hilite(reverse)
   $ type(output) intens(high) caps(off) just(asis ) color(white)
      hilite(reverse)
   ` type(text) intens(high) caps(off) just(asis ) color(yellow)
   ~ type(text) intens(high) caps(off) just(asis ) color(turq)
   @ type(text) intens(high)
   + type(text  ) intens(low )
     skip(on)
   # area(SCRL) Extend(ON)
)Body
+------------------! Print Data via TCP/IP LPR Information +--------------------
@Command ===>_zcmd
@
+
#help -------------------------------------------------------------------------#
)Area Help
`    Information on Printing to TCP/IP Connected Printers using LPR
~
~    This ISPF application provides an easy to use interface for printing
~    user data on printers that are remotely attached via the TCP/IP network.
~
~    LPR is the TCP/IP Line Printer client command that prints the user
~    information on a remote printer connected via the TCP/IP network.  It
~    communicates to the LPD (Line Printer server) on a remote Host on
~    which the requested printer is attached.
~
~    The information that is asked for on the panel is:
~
`    Input Data Set      ===>
~
~    This is the data set name that contains the information that is to be
~    printed on the remote printer.  The format is:
~
~              user.data
~              user.data(member)
~              'prefix.user.data'
~
`    Printer Name        ===>
~
~    This is the name of the printer as it is identified to the Host
~    on which the printer is attached.
~
~       e.g.   lpt1
~              IBM4019L
~
`    Host Name (node)    ===>
~
~    This is the TCP/IP Host Name on which the LPD (Line Printer server)
~    is active that owns the specified printer.
~
~       e.g.   iscprint.rockwell.com
~
`    Binary              ===>
~
~    Used to specify if the user data is to be translated from EBCDIC
~    to ASCII.  Specify`Yes~if the data is already in ASCII format and
~    is not to be translated by the LPR command.
~
`    Carriage Control    ===>
~
~    Specify`Yes~if the data to be printed contains carriage control
~    and the DCB of the data set does not indicate this fact.  Otherwise
~    specify`No~.  If the DCB contains carriage control then it will be
~    used.
~
`    Copies              ===>
~
~    Indicates the number of copies of the data to be printed.
~
`    Lines per Page      ===>
~
~    Indicates the number of lines of data per page to be printed before
~    a new page is forced.  By specifying 0 the maximum number of lines
~    per page allowed by the printer will be printed.
~
`    Header Info         ===>
~
~    Indicates if you want a header printed with the name of the data set
~    being printed on the top of every page.  Only for No Binary and No CC.
~
`    Burst Page          ===>
~
~    Indicates if you want a banner page to be printed before your
~    data.  This page is used as a separator page between multiple
~    print requests and contains the ISPF Host Name, TSO Userid, and
~    the data set name being printed.
~
`    Notify Complete     ===>
~
~    This option will request that an electronic mail message be generated
~    to you when the data has completed printing on the printer.
~    !Note:`this is not supported by all versions of LPD so even if you
~          `request the message, you may not receive it.
~
`    PostScript          ===>
~
~    This option may be Portrait, Landscape, or No.  If 'no' is specified then
~    no Postscript control headers will be generated for printing on a Postscrpt
~    printer.  Portrait and Landscape will cause the appropriate headers to be
~    inserted into the data stream. `Do not use this on a true Postscript file.
~
`    Other Options       ===>
~
~    This option will allow the user to enter other LPR options that are not
~    directly supported by this dialog.
+
!Note:`Use the Enter key to just scroll down this tutorial or
`      Use key $LEFT`to scroll down and key $RIGHT`to scroll up.
)Init
  .cursor = zcmd
  &left  = PFK(LEFT)
  &right = PFK(RIGHT)
)Proc
 &ZCONT = LPRPH0
)end
>PANEL LPRPRINT
)Attr
   @ type( input) intens(high) caps(off) just(left ) pad('_')
     color(blue)
   ! type( input) intens(high) caps(off) just(left ) color(blue)
   _ type( input) intens(high) caps(on ) just(left )
   ^ type(text) intens(low ) caps(off) just(asis ) color(blue)
         hilite(uscore)
   | type(text) intens(high) caps(off) just(asis ) color(blue)
         hilite(uscore)
   # type(text) intens(high) caps(on) just(left ) color(yellow)
         hilite(uscore)
   ` type(text) intens(high) caps(off) just(asis ) color(turq)
   ~ type(text) intens(low ) caps(off) just(asis ) color(turq)
   % type(text) intens(low ) caps(off) just(asis ) color(blue)
)Body
+--------------------% Print Data via TCP/IP LPR Command +----------------------
%Command ===>_zcmd
`
`Enter/Verify:
`    Input Data Set    %===>_lprpinds                                         +
%
`    Printer Name      %===>!lprdest                                          +
`    Host Name (node)  %===>!lprhost                                          +
%
`    Binary            %===>!lprbin+   Use if the file is already ASCII
`    Carriage Control  %===>!lprcc+    Honor Carriage Control in Column 1
`    Copies            %===>!lprcopy+
`    Lines per Page    %===>!lprlcnt+  Lines per page if no CC or (0=default)
`    Header Info       %===>!lprhead+  Generate header information
`    Burst Page        %===>!lprburst+ Generate a burst page on the printer
`    Notify Complete   %===>!lprntfy+  Send Mail when print complete
`    PostScript        %===>!lprps    +Portrait, Landscape, or No
`    Other Options     %===>@lpruopt                                           +
`
)Init
 .HELP = lprph0
 .cursor  = lprpinds
 &lprbin  = trans(trunc(&lprbin,1) Y,Yes N,No y,Yes n,No &z,No)
 &lprcc   = trans(trunc(&lprcc,1) Y,Yes N,No y,Yes n,No &z,No)
 &lprcopy = trans(&lprcopy &z,1 *,*)
 &lprlcnt = trans(&lprlcnt &z,0 *,*)
 &lprhead = trans(trunc(&lprhead,1) Y,Yes N,No y,Yes n,No &z,Yes)
 &lprburst= trans(trunc(&lprburst,1) Y,Yes N,No y,Yes n,No &z,Yes)
 &lprntfy = trans(trunc(&lprntfy,1) Y,Yes N,No y,Yes n,No &z,No)
 &lprps   = trans(trunc(&lprps,1) P,Portrait, L,Landscape N,No
                                  p,Portrait, l,Landscape n,No &z,No)
)Reinit
 .cursor = lprpinds
 &lprbin  = trans(trunc(&lprbin,1) Y,Yes N,No y,Yes n,No &z,No)
 &lprcc   = trans(trunc(&lprcc,1) Y,Yes N,No y,Yes n,No &z,No)
 &lprcopy = trans(&lprcopy &z,1 *,*)
 &lprlcnt = trans(&lprlcnt &z,0 *,*)
 &lprhead = trans(trunc(&lprhead,1) Y,Yes N,No y,Yes n,No &z,Yes)
 &lprburst= trans(trunc(&lprburst,1) Y,Yes N,No y,Yes n,No &z,Yes)
 &lprntfy = trans(trunc(&lprntfy,1) Y,Yes N,No y,Yes n,No &z,No)
 &lprps   = trans(trunc(&lprps,1) P,Portrait, L,Landscape N,No
                                  p,Portrait, l,Landscape n,No &z,No)
)Proc
 &lprbin = trans(trunc(&lprbin,1) Y,Yes N,No y,Yes n,No &z,No *,*)
 &lprcc   = trans(trunc(&lprcc,1) Y,Yes N,No y,Yes n,No &z,No *,*)
 &lprcopy = trans(&lprcopy &z,1 *,*)
 &lprlcnt = trans(&lprlcnt &z,0 *,*)
 &lprhead = trans(trunc(&lprhead,1) Y,Yes N,No y,Yes n,No &z,Yes *,*)
 &lprburst= trans(trunc(&lprburst,1) Y,Yes N,No y,Yes n,No &z,Yes *,*)
 &lprntfy = trans(trunc(&lprntfy,1) Y,Yes N,No y,Yes n,No &z,No *,*)
 &lprps   = trans(trunc(&lprps,1) P,Portrait, L,Landscape N,No
                                  p,Portrait, l,Landscape n,No &z,No *,*)
 ver (&lprpinds,nonblank,dsname,msg=lpr001)
 ver (&lprdest,nb)
 ver (&lprhost,nb)
 ver (&lprbin,nb,list,Yes,No)
 ver (&lprcc,nb,list,Yes,No)
 ver (&lprcopy,nb,num)
 ver (&lprlcnt,nb,num)
 ver (&lprhead,nb,list,Yes,No)
 ver (&lprburst,nb,list,Yes,No)
 ver (&lprntfy,nb,list,Yes,No)
 ver (&lprps,nb,list,Portrait,Landscape,No)
)End
>PANEL LPRPM
)ATTR
  _ TYPE(INPUT) CAPS(OFF) INTENS(HIGH)
  | AREA(DYNAMIC) SCROLL(ON) EXTEND(ON)
  + TYPE(TEXT) INTENS(LOW)
  ¢ TYPE(OUTPUT) INTENS(HIGH) JUST(RIGHT) PAD(0)
 01 TYPE(DATAIN) INTENS(HIGH) CAPS(ON)
 02 TYPE(DATAOUT) INTENS(LOW)
 03 TYPE(DATAIN)  INTENS(HIGH) CAPS(ON)
 04 TYPE(DATAOUT)  INTENS(LOW)
 05 TYPE(DATAOUT)  INTENS(HIGH)
 06 TYPE(DATAOUT)  INTENS(LOW)
)BODY WIDTH(80)
%Member List -- &ZDSN --------------------------------------%ROW¢ZMLCR%OF¢ZMLTR+
%Command ===>_ZCMD                                            %Scroll ===>_Z   +
%Commands:      LOCATE, RESET, SELECT, SORT, HELP                              +
%Line commands: / or S = Select, B = Browse                                    +
&ZMLCOLS
|ZDATA ------------------------------------------------------------------------|
|                                                                              |
| -----------------------------------------------------------------------------|
)INIT
  .ZVARS = 'ZSCML'         /* SCROLL AMT VARIABLE NAME  */
  .HELP = ISR01130
)PROC
  VPUT (ZSCML) PROFILE
)END
 /*  $M1= MEMLIST   M230     860923   158590 : FUNCTION TEST          */
 /*   PTM00000184                                                     */
 /*                                                                   */
 /*   CHANGED 3 LINES                                            3@M1C*/
/* 5665-402 (C) COPYRIGHT IBM CORP 1980, 1989 */
>MSG LPR00
LPR001
'Input data set name must be specified and must be a valid dsname'
LPR002  '&LPRSMSG' .WINDOW=NORESP .TYPE=NOTIFY
'&LPRLMSG'
>END   */
./ ADD NAME=LPREDIT
/* --------------------  rexx procedure  -------------------- *
 * Name:      LPREDIT                                         *
 *                                                            *
 * Function:  ISPF Edit macro to invoke LPRPRINT              *
 *            on the active data set                          *
 *                                                            *
 * Syntax:    LPREDIT                                         *
 *                                                            *
 * Author:    Lionel B. Dyck                                  *
 *                                                            *
 * History:                                                   *
 *            02/14/18 - Add NEWAPPL                          *
 *            03/20/14 - Creation                             *
 *                                                            *
 * ---------------------------------------------------------- */
 Address ISREdit
 'Macro'
 "(currdsn)  = DATASET"
 "(currmem) = MEMBER"

 if length(currmem) = 0
    then mem = ''
    else mem = '('currmem')'

 dataset = "'"currdsn""mem"'"

 Address ISPExec 'Select cmd(%lprprint' dataset ') newappl(isr)'
./ ADD NAME=PSPRINT
        /* ---------------------  rexx procedure  ---------------------- *
         * Name:      PSPRINT                                            *
         *                                                               *
         * Function:  Convert a text file into a PostScript print        *
         *            stream.                                            *
         *                                                               *
         * Syntax:    %PSPRINT input-file output-file / options          *
         *                                                               *
         * where:                                                        *
         *        input-file is the data set name of the input text file *
         *        output-file is optional and is the data set name that  *
         *           will contain the postscript results.                *
         *           - if not specified this is dynamically generated.   *
         *           - if specified the output file will not be deleted  *
         *             at the end of processing.                         *
         *           - if specified as @ then the ISPF dialog will be    *
         *             invoked for additional prompting.                 *
         *       / is the delimeter used to offset the options           *
         *       options are optional values which may be:               *
         *           PORT, WIDE, LAND, or 2UP for print orientation      *
         *           DEBUG to cause tracing of the rexx program          *
         *             during execution                                  *
         *           NOLPR to prevent the execution of the LPRPRINT exec.*
         *                                                               *
         * If no parameters are entered then the ISPF Dialog is invoked. *
         *                                                               *
         * Defaults:                                                     *
         *            PORT orientation and delete the output file after  *
         *            invoking the lprprint procedure.                   *
         *                                                               *
         * Author:    Lionel B. Dyck                                     *
         *            Rockwell International                             *
         *            P.O. Box 2515                                      *
         *            Seal Beach, California 90740                       *
         *            (310) 797-1125                                     *
         *            IBMMail:  USROKNTN                                 *
         *            Internet: lbd@osreq48.rockwell.com                 *
         *            IBMLINK:  ROK2027                                  *
         *                                                               *
         * History:                                                      *
         *           02/22/96 - display dialog even if dsname provided   *
         *           09/26/94 - minor bug fix in parse                   *
         *           09/02/94 - Reset LPRPRINT lprps to no               *
         *           08/25/94 - Fix test for options                     *
         *           04/27/94 - Add prompt option                        *
         *           01/26/94 - updated to support non-ISPF usage        *
         *           01/20/94 - created for TSO/ISPF                     *
         *                                                               *
         * Originally based upon the PSPRINT.cmd                         *
         * Written by Michael Perks (10/31/92)                           *
         * (c) Copyright IBM Corp. 1992 All Rights Reserved              *
         * modified to allow an option of lptn                           *
         *                                                               *
         * modified to run under MVS TSO/E by Lionel Dyck                *
         * to use PostScript programming by Carl J. Lydick               *
         * of CalTech picked up from comp.lang.postscript.               *
         *                                                               *
         * This eliminates the calculation of line placement and         *
         * page ejects and provides the following options:               *
         *                                                               *
         * PORT -  Portrait 80 characters by 60 lines in 11 pt. Courier  *
         * WIDE -  Portrait 132 characters by 103 lines in 6 pt. Courier *
         * LAND -  Landscape 132 characters by 60 lines in 9 pt. Courier *
         * 2UP  -  2 pages 80 characters by 66 lines side by side        *
         *         in landscape in 6 pt. Courier                         *
         *                                                               *
         * ------------------------------------------------------------- */

        parse arg psinds outname "/" options

        outname = translate(strip(outname))

        if length(psinds) >= 0 then prompt = 1
        if outname        = "@" then prompt = 1
           else if length(outname) > 0 then prompt = 0
        if length(options) > 0 then prompt = 0

        cmd = sysvar("sysicmd")
        spf = sysvar("sysispf")

        if prompt = 1 then do forever
           if spf <> "ACTIVE" then do
              say cmd": Not running under ISPF and no parameters specified"
              say cmd": terminating - review the documentation and retry."
              exit 8
              end
           Address ISPEXEC
           "Display Panel(PSPRINT)"
           if rc > 3 then exit
           if lpr = "No" then lpr = "NOLPR"
                         else lpr = ""
           if "OK" <> sysdsn(psinds) then do
               smsg = "Error"
               lmsg = sysdsn(psinds)
               "Vput (Smsg Lmsg)"
               "Setmsg Msg(Pspr002)"
                end
           else call test_pds
        end

        if length(options) > 0 then
           options = translate(options)

        /* test options for debug */
        if wordpos("DEBUG",options) > 1 then do
           trace "?i"
           x = wordpos("DEBUG",options)
           new_opt = delword(options,x,1)
           options = new_opt
           end

        /* test options for nolpr */
        if wordpos("NOLPR",options) > 1 then do
           no_lpr = "on"
           no_del = "on"
           x = wordpos("NOLPR",options)
           new_opt = delword(options,x,1)
           options = new_opt
           end

        if spf <> "ACTIVE" then no_lpr = "on"

        if length(outname) = 0 then do
           d = date(u)
           date = substr(d,7,2)substr(d,1,2)substr(d,4,2)
           s = time("L")  /* get the current time hh:mm:ss.th */
           t = substr(s,1,2)substr(s,4,2)substr(s,7,2)substr(s,10,1)
           prefix = sysvar(syspref)
           pscript_dsn = "'"prefix".pscript.D"date".T"t".ps'"
           end
        else do
             pscript_dsn = outname
             no_del = "on"
             end

        out. = ""

        Select
          When options = "PORT" then call do_port
          When options = "WIDE" then call do_wide
          When options = "LAND" then call do_land
          When options = "2UP"  then call do_2up
          Otherwise call do_port
          end

        /* test the existence of the input data set */
        if "OK" <> sysdsn(psinds) then
        do
            smsg = "Error"
            lmsg = sysdsn(psinds)
            call do_msg
            exit
        end

        x = listdsi(psinds)
        if pos("(",psinds) > 0 then sysdsorg = "PS"
        if sysdsorg = "PO" then do
           if spf <> "ACTIVE" then do
              say cmd": Has specified a partitioned data set:",
                        psinds
              say cmd": which is not supported by this command",
                     "outside of the ISPF enviornment."
              say cmd": Terminating processing.  Specify a member",
                     "name and retry."
              exit
              end
           Address ISPEXEC
           call do_pds
           exit
           end

        /* generate a ddname and dynamically allocate the output
           data set. */
        pscript_odd = "PSXO"random()
        "Alloc f("pscript_odd") ds("pscript_dsn") New Spa(30,30) Tr",
              "Recfm(V B) Lrecl(255) Blksize(0) Dsorg(PS)"

        /* read each line, quote characters and then output */
        pscript_idd = "PSXi"random()
        "Alloc f("pscript_idd") ds("psinds") Shr"
        "Execio * diskr" pscript_idd "(Finis stem in."
        "Free f("pscript_idd")"

        "Execio * diskw" pscript_odd "(stem out."
        "Execio * diskw" pscript_odd "(Finis stem in."
        "Free f("pscript_odd")"

        drop out. in.

        if no_lpr <> "on" then do
          if spf = "ACTIVE" then do
             Address ISPEXEC "Vget (lprps) Profile"
             hold_lprps = lprps
             lprps = "No"
             Address ISPEXEC "Vput (lprps) Profile"
             end
          "%lprprint" pscript_dsn
          lprps = hold_lprps
          if spf = "ACTIVE" then
             Address ISPEXEC "Vput (lprps) Profile"
          end

        x = msg("OFF")
        if no_del <> "on" then
          "Delete" pscript_dsn
          else do
            smsg = ""
            lmsg = "Output dsname is:" pscript_dsn
            call do_msg
            end

        exit

        do_msg:
            if spf = "ACTIVE" then do
               Address ISPEXEC
               "Vput (Smsg Lmsg)"
               "Setmsg Msg(Pspr002)"
               end
            else do
                 say smsg
                 say lmsg
                 end
            return

        do_port:

        do_port:
        out.1 = "%!PS-Adobe-1.0"
        out.2 = "%%Creator: Carl J Lydick"
        out.3 = "%%DocumentFonts: Courier"
        out.4 = "%%Pages: (atend)"
        out.5 = "/Courier findfont 11 scalefont setfont"
        out.6 = "/P {showpage /H 750 def} def"
        out.7 = "/Q { 36 H moveto dup length 80 gt {0 80 getinterval}",
                " if show /H H 12 sub def"
        out.8 = "   H 30 le {P} if} def"
        out.9 = "/R 0 def"
        out.10 = "/S 512 string def"
        out.11 = '/T {(", FF, ") search {R 0 ne {Q pop P} {pop pop /R 1 def}',
                " ifelse T} if} def"
        out.12 = "/L {/H 750 def {currentfile S readline not {exit} if T Q}",
                " loop showpage} def"
        out.13 = "L"
        out.0 = 13
        return

        do_wide:
        out.1 = "%!PS-Adobe-1.0"
        out.2 = "%%Creator: Carl J Lydick"
        out.3 = "%%DocumentFonts: Courier"
        out.4 = "%%Pages: (atend)"
        out.5 = "/Courier findfont 6 scalefont setfont"
        out.6 = "/P {showpage /H 750 def} def"
        out.7 = "/Q { 36 H moveto dup length 132 gt {0 132 getinterval}",
                " if show /H H 7 sub def"
        out.8 = "   H 30 le {P} if} def"
        out.9 = "/R 0 def"
        out.10 = "/S 512 string def"
        out.11 = '/T {(", FF, ") search {R 0 ne {Q pop P}',
                 " {pop pop /R 1 def} ifelse T} if} def"
        out.12 = "/L {/H 750 def {currentfile S readline not",
                 " {exit} if T Q} loop showpage} def"
        out.13 = "L"
        out.0 = 13
        return

        do_land:
        out.1 = "%!PS-Adobe-1.0"
        out.2 = "%%Creator: Carl J Lydick"
        out.3 = "%%DocumentFonts: Courier"
        out.4 = "%%Pages: (atend)"
        out.5 = "/Courier findfont 9 scalefont setfont"
        out.6 = "/P {showpage 90 rotate 0 -618 translate /H 594 def} def"
        out.7 = "/Q {36 H moveto dup length 132 gt {0 132 getinterval}",
                " if show /H H 9.5 sub def"
        out.8 = "    H 30 le {P} if} def"
        out.9 = "/R 0 def"
        out.10 = "/S 512 string def"
        out.11 = '/T {(", FF, ") search {R 0 ne {Q pop P}',
                 " {pop pop /R 1 def} ifelse T} if} def"
        out.12 = "/L {90 rotate 0 -618 translate /H 594 def",
                 " {currentfile S readline not {exit} if"
        out.13 = " T Q} loop showpage} def"
        out.14 = "L"
        out.0 = 14
        return

        do_2up:
        out.1 = "%!PS-Adobe-1.0"
        out.2 = "%%Creator: Carl J Lydick"
        out.3 = "%%DocumentFonts: Courier"
        out.4 = "%%Pages: (atend)"
        out.5 = "/Courier findfont 6 scalefont setfont"
        out.6 = "/N {showpage 90 rotate 0 -618 translate /H 538",
                " def /V 71 def} def"
        out.7 = "/O {/H 538 def /V 431 def} def"
        out.8 = "/P {V 431 ne {O} {N} ifelse} def"
        out.9 = "/Q { V H moveto dup length 80 gt {0 80 getinterval}",
                " if show /H H 7 sub def"
        out.10 = "   H 79 le {P} if} def"
        out.11 = "/R 0 def"
        out.12 = "/S 512 string def"
        out.13 = '/T {(", FF, ") search {R 0 ne {Q pop P} {pop pop',
                 " /R 1 def} ifelse T} if} def"
        out.14 = "/L {90 rotate 0 -618 translate /H 538 def /V 71 def"
        out.15 = "   {currentfile S readline not {exit} if T Q}",
                 " loop showpage} def"
        out.16 = "L"
        out.0 = 16
        return

        test_pds:
              x = listdsi(psinds)
              if pos("(",psinds) > 0 then sysdsorg = "PS"
              Select
                When sysdsorg = "PS" | pos("(",psinds) > 1
                     then
                     "Select Cmd(%"cmd  psinds psopds "/" pstype lpr ")"
                When sysdsorg = "PO"
                     then call do_pds
                Otherwise nop;
              end
        return

        do_pds:
            "Lminit Dataid(dataid) Dataset("psinds") Enq(Shrw)"
            "Lmopen Dataid("dataid") Option(Input)"
            "Lmmdisp Dataid("dataid") Option(Display)",
              "Commands(Any) Panel(PsprM)"
              do while rc == 0
                 Call process_selection
                "Lmmdisp Dataid("dataid") Option(Get)"
                 if rc == 8
                    then "Lmmdisp Dataid("dataid") Option(Display)",
                         "Commands(Any) Panel(LPRPM)"
              end
              "Lmmdisp Dataid("dataid") Option(Free)"
              "Lmclose Dataid("dataid")"
              "Lmfree  Dataid("dataid")"
            return

         process_selection:
            if left(psinds,1) = "'"
               then parse value psinds with "'" w_dsn "'"
               else w_dsn = sysvar("syspref")"."psinds
            zlmember = strip(zlmember)
            Select
            When zllcmd = "/" | zllcmd = "S"
            Then do
              "Lmmdisp Dataid("dataid") Option(Put) Member("zlmember")",
                  "Zludata(printed)"
              "Select Cmd(%"cmd  "'"w_dsn"("zlmember")'",
                  psopds "/" pstype lpr ")"
              end
            When zllcmd = "B"
            Then "Browse Dataid("dataid") Member("zlmember")"
            Otherwise nop;
            End
            return
